diff --git a/.reviewboardrc b/.reviewboardrc
index 1d3053a..900fa22 100644
--- a/.reviewboardrc
+++ b/.reviewboardrc
@@ -1,3 +1,3 @@
 REVIEWBOARD_URL = 'http://e95cr.ddns.net/'
-REPOSITORY = 'CSCI E-95 - Vikram Gigoo'
+REPOSITORY = 'CSCI E-95 - Your Name Here'
 
diff --git a/assignments/Questionnaire.txt b/assignments/Questionnaire.txt
index 01c53e9..d16d28f 100644
--- a/assignments/Questionnaire.txt
+++ b/assignments/Questionnaire.txt
@@ -6,60 +6,57 @@
 			     Spring 2015
 
 
-Name:	Vikram Gigoo			Work phone number: 
+Name:				Work phone number:
 
 
-E-mail:	gigoo.vikram@gmail.com		Home phone number: 508 308 2065
+E-mail:				Home phone number:
 
 
-Occupation: Software Engineer
+Occupation:
 
 	If you're a full-time student, what is your department, field, and
 	    year and at which school?  Are you currently in a degree program?
-N/A
+
 
 Have you taken CSCI E-10a (Formerly E-50a), CSCI E-10b (Formerly E-50b),
 CSCI E-50 (Formerly E-52), and/or CSCI E-28 (Unix Systems Programming)
 (Formerly CSCI E-215) or equivalents (specify which)?
-I have taken equivalent courses in my undergrad
+
 
 Have you taken CSCI E-22 (Data Structures) (Formerly CSCI E-119)?
 
 	If not, how do you meet the prerequisite?
 
-I have taken an equivalent course in my undergrad
 
 Have you taken CSCI E-124 (Data Structures and Algorithms)?
 
 	If not, how do you meet the prerequisite?
-I have taken an equivalent course in my undergrad
 
 
 Are you already registered for this class?  -- If not, do you intend
 to register?
-Yes
+
 
 What additional appropriate course or work experience do you have?
-I have been working as a software engineer for the last 3 years 
+
 
 What is your math background?
-I have worked with a decent amount of math in grad school in study of physical communication channels (for information theory, channel coding, digital signal processing, etc). However I haven't dealt with math over the last 4 years since grad school.
+
 
 What computer languages do you know (please include assembler and
 high-level languages)?
-C++, JAVA, MATLAB
-I have worked with Verilog, TCL, Perl and Python in the past
+
 
 What operating systems have you used?
-Linux (Ubuntu generally) and Windows
+
 
 What computers have you used?
-Intel processor based computers (HP, Dell, Lenovo)
+
 
 Why are you taking the course?
-Its an interesting topic and it shall be useful in understanding the theory behind some of the code generation tools I work on in my day job.
+
 
 If the class needs to be rescheduled, is Thursday evening acceptable?
-Yes
+
 
 Other comments (please continue on the back):
diff --git a/src/Makefile b/src/Makefile
index 8154f5f..6550cd2 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -22,14 +22,13 @@ LDFLAGS =
 EXECS = compiler
 
 # House-keeping build targets.
-# Make sure to set PARSER to 1 
-# and DEBUG to 0(if you don't want text pollution) in scanner.lex
+
 all : $(EXECS)
 
 clean :
 	rm -f $(EXECS) *.o scanner.c parser.c parser.h
 
-%.c : %.lex
+%.c : %.l
 	$(LEX) $(LEXFLAGS) -o $@ $<
 
 %.c : %.y
@@ -55,4 +54,4 @@ mips.o : mips.c mips.h ir.h type.h symbol.h node.h
 
 compiler.o : compiler.c mips.h ir.h type.h symbol.h node.h parser.h scanner.h
 compiler: compiler.o parser.o scanner.o node.o symbol.o type.o ir.o mips.o
-	$(CC) -o $@ $(LDFLAGS) $^ $(LDLIBS)
+	$(CC) -o $@ $(LDFLAGS) $^ $(LDLIBS)
\ No newline at end of file
diff --git a/src/README b/src/README
index c2eaf71..6fdda98 100644
--- a/src/README
+++ b/src/README
@@ -1,56 +1,25 @@
-NOTE: I renamed scanner.l to scanner.lex as that helped color coding on emacs on my machine by default. I have updated the Makefiles for it.
+To build type:
 
-Build and Test setup
+make 
 
-1. Testing with Parser and Node files - Full scale testing
----------------------------------------------------------
-Switches to handle :
-Set PARSER_DEFINED to 1 and DEBUG to 0 (in scanner.lex)
+or
 
-Build:
- make
+make scanner
 
-Remove built files
- make clean 
 
-USAGE: 
- compiler -scanner [-i inputFileName] [-o outputFileName]
- 
- default value of 
-          inputFileName = stdin
-          outputFileName = stdout
- 
-Test file used and attached with submission:
- src/tokens.txt 
 
-Input:
- a. stdin if no input file provided 
- b. Input file provided as an argument
+To run unit tests type (will build scanner if not already built):
 
-Output:
- stdout or outputFile
+make test
 
-2. Standalone build for checking token assignment 
----------------------------------------------------------
-Switches to handle :
-Set PARSER_DEFINED to 0 and DEBUG to 1 (in scanner.lex)
 
-Command to Build:
- make -f StandaloneMakefile
+To clean (doesn't remove scanner executable):
 
-Remove built files
- make clean 
-
-Usage:
- lexer 
-
-Input:
- stdin
-
-Output
- stdout
+make clean 
 
+To clobber (removes lexer):
 
+make clobber
 
 
 ===============================================================================
@@ -65,11 +34,11 @@ will read the provided file (or standard input) and produce as output a stream
 of lines, each line representing a token in the source language.
 
 Usage:
-    compiler -s scanner [-i <input>] [-o <output>]
+    scanner [<input>] [<output>]
 
 Both the input filename and output filename are optional. If the input filename
-is not specified , it is assumed to be stdin. If the output
-filename is not specified , it is assumed to be stdout.
+is not specified or is given as '-', it is assumed to be stdin. If the output
+filename is not specified or is given as '-', it is assumed to be stdout.
 
 The input file should be a (lexically) valid source language program. Output 
 consists of lines with tab separated fields:
diff --git a/src/compiler.c b/src/compiler.c
index a41b149..d5ba17a 100644
--- a/src/compiler.c
+++ b/src/compiler.c
@@ -14,8 +14,6 @@
 #include "scanner.h"
 #include "parser.h"
 
-#define LOG_OUTPUT 1
-
 int yyparse();
 extern int yynerrs;
 
@@ -32,9 +30,8 @@ int scan_only(FILE *output) {
   /* Begin scanning. */
   int num_errors = 0;
   int token = yylex();
-
   while (0 != token) {
-    char *token_type; const char *token_name;
+    char *token_type, *token_name;
 
     /*
      * Print the line number. Use printf formatting and tabs to keep columns
@@ -55,85 +52,52 @@ int scan_only(FILE *output) {
     if (token > 0) {
       /* Found a token! */
 
-      /* To avoid issues of mapping enums to string array, *
-	 using dumb switch case here for getting token name*/
-
       /* Look up and print the token's name. */
       /* Print information about the token. */
       switch (token) {
-      case CHAR:    token_type = "rsvwd";token_name = "CHAR";break;
-      case SHORT:   token_type = "rsvwd";token_name = "SHORT";break;
-      case INT:     token_type = "rsvwd";token_name = "INT";break;
-      case LONG:    token_type = "rsvwd";token_name = "LONG";break;
-      case SIGNED:  token_type = "rsvwd";token_name = "SIGNED";break;
-      case UNSIGNED:token_type = "rsvwd";token_name = "UNSIGNED";break;
-      case VOID:    token_type = "rsvwd";token_name = "VOID";break;
-
-      case DO:      token_type = "rsvwd";token_name = "DO";break;
-      case FOR:     token_type = "rsvwd";token_name = "FOR";break;
-      case RETURN:  token_type = "rsvwd";token_name = "RETURN";break;
-      case BREAK:   token_type = "rsvwd";token_name = "BREAK";break;
-      case CONTINUE:token_type = "rsvwd";token_name = "CONTINUE";break;
-      case WHILE:   token_type = "rsvwd";token_name = "WHILE";break;
-	
-      case IF:      token_type = "rsvwd";token_name = "IF";break;
-      case ELSE:    token_type = "rsvwd";token_name = "ELSE";break;
-      case GOTO:    token_type = "rsvwd";token_name = "GOTO";break;
-
-      case ASTERISK:token_type = "op"; token_name = "ASTERISK";break;
-      case MINUS:   token_type = "op"; token_name = "MINUS";break;
-      case PLUS:    token_type = "op"; token_name = "PLUS";break;
-      case EQUAL:   token_type = "op"; token_name = "EQUAL";break;
-      case SLASH:   token_type = "op"; token_name = "SLASH";break;
-      case LEFT_PAREN:token_type = "op"; token_name = "LEFT_PAREN";break;
-      case RIGHT_PAREN:token_type = "op"; token_name = "RIGHT_PAREN";break;
-      case LEFT_SQUARE:token_type = "op"; token_name = "LEFT_SQUARE";break;
-      case RIGHT_SQUARE:token_type = "op"; token_name = "RIGHT_SQUARE";break;
-      case LEFT_CURLY:token_type = "op"; token_name = "LEFT_CURLY";break;
-      case RIGHT_CURLY:token_type = "op"; token_name = "RIGHT_CURLY";break;
-      case AMPERSAND:token_type = "op"; token_name = "AMPERSAND";break;
-      case SEMICOLON:token_type = "op"; token_name = "SEMICOLON";break;
-      case CARET:    token_type = "op"; token_name = "CARET";break;
-      case COLON:    token_type = "op"; token_name = "COLON";break;
-      case COMMA:    token_type = "op"; token_name = "COMMA";break;
-      case EXCLAMATION:token_type = "op"; token_name = "EXCLAMATION";break;
-      case GREATER:  token_type = "op"; token_name = "GREATER";break;
-      case LESS:     token_type = "op"; token_name = "LESS";break;
-      case PERCENT:  token_type = "op"; token_name = "PERCENT";break;
-      case QUESTION: token_type = "op"; token_name = "QUESTION";break;
-      case TILDE:    token_type = "op"; token_name = "TILDE";break;
-      case VBAR:     token_type = "op"; token_name = "VBAR";break;
-      case AMPERSAND_AMPERSAND:token_type = "op"; token_name = "AMPERSAND_AMPERSAND";break;
-      case AMPERSAND_EQUAL:token_type = "op"; token_name = "AMPERSAND_EQUAL";break;
-      case ASTERISK_EQUAL:token_type = "op"; token_name = "ASTERISK_EQUAL";break;
-      case CARET_EQUAL:   token_type = "op"; token_name = "CARET_EQUAL";break;
-      case EQUAL_EQUAL:   token_type = "op"; token_name = "EQUAL_EQUAL";break;
-      case EXCLAMATION_EQUAL: token_type = "op"; token_name = "EXCLAMATION_EQUAL";break;
-      case GREATER_EQUAL: token_type = "op"; token_name = "GREATER_EQUAL";break;
-      case GREATER_GREATER:token_type = "op"; token_name = "GREATER_GREATER";break;
-      case GREATER_GREATER_EQUAL:token_type = "op"; token_name = "GREATER_GREATER_EQUAL";break;
-      case LESS_EQUAL:     token_type = "op"; token_name = "LESS_EQUAL";break;
-      case LESS_LESS:      token_type = "op"; token_name = "LESS_LESS";break;
-      case LESS_LESS_EQUAL:token_type = "op"; token_name = "LESS_LESS_EQUAL";break;
-      case MINUS_EQUAL:    token_type = "op"; token_name = "MINUS_EQUAL";break;
-      case MINUS_MINUS:    token_type = "op"; token_name = "MINUS_MINUS";break;
-      case PERCENT_EQUAL:  token_type = "op"; token_name = "PERCENT_EQUAL";break;
-      case PLUS_EQUAL:     token_type = "op"; token_name = "PLUS_EQUAL";break;
-      case PLUS_PLUS:      token_type = "op"; token_name = "PLUS_PLUS";break;
-      case SLASH_EQUAL:    token_type = "op"; token_name = "SLASH_EQUAL";break;
-      case VBAR_EQUAL:     token_type = "op"; token_name = "VBAR_EQUAL";break;
-      case VBAR_VBAR:      token_type = "op"; token_name = "VBAR_VBAR";break;
-
-      case NUMBER:  token_type = "num"; token_name = "NUMBER";break;
-
-      case IDENTIFIER:	token_type = "id"; token_name = "IDENTIFIER";break;
-
-      case STRING:  token_type = "string"; token_name = "STRING";break;
-
-      default:
-	assert(0);
-	break;
+        case CHAR:
+          token_type = "rsvwd"; token_name = "CHAR"; break;
+        case INT:
+          token_type = "rsvwd"; token_name = "INT"; break;
+        case LONG:
+          token_type = "rsvwd"; token_name = "LONG"; break;
+        case RETURN:
+          token_type = "rsvwd"; token_name = "RETURN"; break;
+        case SHORT:
+          token_type = "rsvwd"; token_name = "SHORT"; break;
+        case SIGNED:
+          token_type = "rsvwd"; token_name = "SIGNED"; break;
+        case UNSIGNED:
+          token_type = "rsvwd"; token_name = "UNSIGNED"; break;
+
+        case ASTERISK:
+          token_type = "op"; token_name = "ASTERISK"; break;
+        case MINUS:
+          token_type = "op"; token_name = "MINUS"; break;
+        case PLUS:
+          token_type = "op"; token_name = "PLUS"; break;
+        case EQUAL:
+          token_type = "op"; token_name = "EQUAL"; break;
+        case SLASH:
+          token_type = "op"; token_name = "SLASH"; break;
+        case LEFT_PAREN:
+          token_type = "op"; token_name = "LEFT_PAREN"; break;
+        case RIGHT_PAREN:
+          token_type = "op"; token_name = "RIGHT_PAREN"; break;
+        case SEMICOLON:
+          token_type = "op"; token_name = "SEMICOLON"; break;
+
+        case NUMBER:
+          token_type = "num"; token_name = "NUMBER"; break;
+
+        case IDENTIFIER:
+          token_type = "id"; token_name = "IDENTIFIER"; break;
+
+        default:
+          assert(0);
+          break;
       }
+
     } else {
       token_type = "error"; token_name = "ERROR";
       num_errors++;
@@ -143,92 +107,62 @@ int scan_only(FILE *output) {
 
     if (0 == strcmp("number", token_type)) {
       /* Print the type and value. */
-      const char* typeStr = NULL;
-      if (type_is_unsigned(yylval->data.number.result.type))
-	typeStr = "UNSIGNED";
-      else
-	typeStr = "SIGNED";
       fprintf(output, "   type = %8s %-12s   value = %-10lu\n",
-              typeStr, "LONG", yylval->data.number.value);
-      /* Overflow*/
-      if(yylval->data.number.overflow)
-	fprintf(output, "\n ERROR:Overflow detected \n");
-
+              "UNSIGNED", "LONG", yylval->data.number.value);
+      /* This might be a good place to indicate overflow if it happened. */
     } else if (0 == strcmp("id", token_type)) {
         fprintf(output, "    name = %s\n", yylval->data.identifier.name);
-    } else if (0 == strcmp("string", token_type)){
-      fprintf(output, "    string = %s , length = %d \n", yylval->data.string.str, yylval->data.string.strLen);
     } else {
       fputs("\n", output);
     }
 
     token = yylex();
   }
-
   return num_errors;
 }
 
 int main(int argc, char **argv) {
   FILE *output;
-  FILE* input;
   int result;
   struct symbol_table symbol_table;
   char *stage;
   int opt;
 
   output = NULL;
-  optarg = NULL;
   stage = "mips";
-  while (-1 != (opt = getopt(argc, argv, "o:s:i:"))) {
+  while (-1 != (opt = getopt(argc, argv, "o:s:"))) {
     switch (opt) {
-    case 'o':
-      output = fopen(optarg, "w");
-      if (NULL == output) {
-	fprintf(stdout, "Could not open output file %s: %s", optarg, strerror(errno));
-	return -1;
-      }
-      break;
-    case 's':
-      stage = optarg;
-      break;
-    case 'i':
-      input = fopen(optarg, "r");
-      if(input == NULL)
-	printf ("Unable to open file %s \n", optarg);
-      break;
-    }
-    /* Figure out whether we're using stdin/stdout or file in/file out. */
-    if (input == NULL) {
-      yyin = stdin;
-    } else {
-      yyin = input;
+      case 'o':
+        output = fopen(optarg, "w");
+        if (NULL == output) {
+          fprintf(stdout, "Could not open output file %s: %s", optarg, strerror(errno));
+          return -1;
+        }
+        break;
+      case 's':
+        stage = optarg;
+        break;
     }
   }
+  /* Figure out whether we're using stdin/stdout or file in/file out. */
+  if (argc < 2 || !strcmp("-", argv[1])) {
+    yyin = stdin;
+  } else {
+    yyin = fopen(argv[1], "r");
+  }
 
   if (NULL == output) {
     output = fopen("output.s", "w");
   }
 
   if (0 == strcmp("scanner", stage)) {
-    FILE* loggedOutput = stdout;
-    int num_errors = 0;
-    int retVal = 0;
-
-    if(output != NULL)
-      loggedOutput = output;
-
-    num_errors = scan_only(loggedOutput);
-
+    int num_errors = scan_only(stdout);
     if (num_errors > 0) {
-      print_errors_from_pass(loggedOutput, "Scanner", num_errors);/*As yyerror is not being used here -yynerrs*/
-      retVal = 2;
-    } 
-    if(output != NULL)
-      fclose(output);
-    if(input != NULL)
-      fclose(input);
-
-    return retVal;
+      print_errors_from_pass(stdout, "Scanner", yynerrs);
+      return 2;
+    } else {
+      return 0;
+    }
   }
 
   result = yyparse();
diff --git a/src/node.c b/src/node.c
index 610ec67..811d0a1 100644
--- a/src/node.c
+++ b/src/node.c
@@ -8,7 +8,6 @@
 
 #include "node.h"
 #include "symbol.h"
-#include "type.h"
 
 extern int yylineno;
 
@@ -72,8 +71,7 @@ struct node *node_number(char *text)
 
   errno = 0;
   node->data.number.value = strtoul(text, NULL, 10);
-  if (node->data.number.value == ULONG_MAX 
-      && ERANGE == errno) {
+  if (node->data.number.value == ULONG_MAX && ERANGE == errno) {
     /* Strtoul indicated overflow. */
     node->data.number.overflow = true;
   } else if (node->data.number.value > 4294967295ul) {
@@ -82,32 +80,12 @@ struct node *node_number(char *text)
   } else {
     node->data.number.overflow = false;
   }
-  /* Taking common denominator of 2^31-1 and -2^31*/
-  if (node->data.number.value<2147483647)
-    node->data.number.result.type = 
-      type_basic(false, TYPE_WIDTH_LONG);
-  else
-    node->data.number.result.type = 
-      type_basic(true, TYPE_WIDTH_LONG); 
 
+  node->data.number.result.type = NULL;
   node->data.number.result.ir_operand = NULL;
   return node;
 }
 
-struct node *node_string(const char *text, int length)
-{
-  struct node *node = node_create(NODE_STRING);
-  memset(node->data.string.str, 0, MAX_STRING_LENGTH + 1);
-  node->data.string.strLen = (length < MAX_STRING_LENGTH)?length:MAX_STRING_LENGTH;
-
-  strncpy(node->data.string.str, text, node->data.string.strLen);
-
-  node->data.string.result.type = type_basic(true, TYPE_ARRAY);
-  node->data.string.result.ir_operand = NULL;
-  return node;
-}
-
-
 struct node *node_binary_operation(int operation, struct node *left_operand,
                                    struct node *right_operand)
 {
@@ -142,7 +120,7 @@ struct result *node_get_result(struct node *expression) {
       return &expression->data.identifier.symbol->result;
     case NODE_BINARY_OPERATION:
       return &expression->data.binary_operation.result;
-   default:
+    default:
       assert(0);
       return NULL;
   }
diff --git a/src/node.h b/src/node.h
index 9c06ca7..9dd88ad 100644
--- a/src/node.h
+++ b/src/node.h
@@ -7,15 +7,12 @@
 struct type;
 
 #define MAX_IDENTIFIER_LENGTH               31
-#define MAX_STRING_LENGTH                   509
 
 #define NODE_NUMBER                          0
 #define NODE_IDENTIFIER                      1
 #define NODE_BINARY_OPERATION                2
 #define NODE_EXPRESSION_STATEMENT            3
 #define NODE_STATEMENT_LIST                  4
-#define NODE_STRING                          5
-
 struct result {
   struct type *type;
   struct ir_operand *ir_operand;
@@ -48,11 +45,6 @@ struct node {
       struct node *init;
       struct node *statement;
     } statement_list;
-    struct {
-      char str[MAX_STRING_LENGTH + 1]; /*To tie in life time of string to node with minimal code*/
-      int strLen; /* As string could contain '\0'*/
-      struct result result;
-    } string; /*As only this kind of array allowed not naming it array*/
   } data;
 };
 
@@ -66,7 +58,6 @@ struct node {
 /* Constructors */
 struct node *node_number(char *text);
 struct node *node_identifier(char *text, int length);
-struct node *node_string(const char *text, int length);
 struct node *node_statement_list(struct node *list, struct node *item);
 struct node *node_binary_operation(int operation, struct node *left_operand,
                                    struct node *right_operand);
diff --git a/src/scanner.l b/src/scanner.l
index 8f46065..b3d175d 100644
--- a/src/scanner.l
+++ b/src/scanner.l
@@ -3,7 +3,7 @@
 
 %{
 /*
- * scanner.lex
+ * scanner.l
  *
  * This file contains the specification for the (f)lex generated scanner
  * for the CSCI-E295 source language.
@@ -14,290 +14,47 @@
   #include <errno.h>
   #include <string.h>
 
- #define PARSER 0 /* To avoid any parser specific code */
- #define DEBUG 1 /*If you want debug messages printed */
-
- #if PARSER
   #define YYSTYPE struct node *
- #endif
-
   #define YY_NO_INPUT
 
- #if PARSER
   #include "node.h"
   #include "parser.h"
- #else
-  #include "testToken.h"
- #endif 
-  #define MAX_STR_CONST 509 /*From C89 standards*/
-
-
 
-  int echoFcn(int tokenId);
-  int nodeFromChar(int charVal);
 %}
 
-newline         \n[\r]?
+newline         \n
 ws              [ \t\v\f]
 
 digit           [[:digit:]]
 letter          [[:alpha:]]
 
-graphicalChar   [\$\@\`\*\+\-\/]
-
-id              ({letter}|_)({letter}|{digit}|_)*
+id              {letter}({letter}|{digit})*
 number          {digit}+
 
-%x              comment
-%x              string
 %%
-     char string_buf[MAX_STR_CONST];
-     char *string_buf_ptr = NULL;
+
 {newline}   /* do nothing; lex is counting lines */
 {ws}        /* do nothing */
 
   /* operators begin */
-\*          return echoFcn(ASTERISK);
-\+          return echoFcn(PLUS);
-\-           return echoFcn(MINUS);
-\/          return echoFcn(SLASH);
-\=          return echoFcn(EQUAL);
-\%           return echoFcn(PERCENT);
-\&           return echoFcn(AMPERSAND);
-\<           return echoFcn(LESS);
-\>           return echoFcn(GREATER);
-\?           return echoFcn(QUESTION);
-\|           return echoFcn(VBAR);
-
-\&&          return echoFcn(AMPERSAND_AMPERSAND);
-\&=          return echoFcn(AMPERSAND_EQUAL);
-\*=          return echoFcn(ASTERISK_EQUAL);
-\^=          return echoFcn(CARET_EQUAL);
-\==          return echoFcn(EQUAL_EQUAL);
-\!=          return echoFcn(EXCLAMATION_EQUAL);
-\>=          return echoFcn(GREATER_EQUAL);
-\>>          return echoFcn(GREATER_GREATER);
-\>>=         return echoFcn(GREATER_GREATER_EQUAL);
-\<=          return echoFcn(LESS_EQUAL);
-\<<          return echoFcn(LESS_LESS);
-\<<=         return echoFcn(LESS_LESS_EQUAL);
-\-=          return echoFcn(MINUS_EQUAL);
-\%=          return echoFcn(PERCENT_EQUAL);
-\+=          return echoFcn(PLUS_EQUAL);
-\/=          return echoFcn(SLASH_EQUAL);
-\|=          return echoFcn(VBAR_EQUAL);
-\|\|          return echoFcn(VBAR_VBAR);
-
+\*          return ASTERISK;
+\+          return PLUS;
+-           return MINUS;
+\/          return SLASH;
+\=          return EQUAL;
+
+\(          return LEFT_PAREN;
+\)          return RIGHT_PAREN;
+;           return SEMICOLON;
   /* operators end */
 
-  /* Separator*/
-\(          return echoFcn(LEFT_PAREN);
-\)          return echoFcn(RIGHT_PAREN);
-\{           return echoFcn(LEFT_CURLY);
-\}           return echoFcn(RIGHT_CURLY);
-\[           return echoFcn(LEFT_SQUARE);
-\]           return echoFcn(RIGHT_SQUARE);
-
-,           return echoFcn(COMMA);
-:           return echoFcn(COLON);
-!          return echoFcn(EXCLAMATION);
-;            return echoFcn(SEMICOLON);
-
-
-  /* Handle '0' by itself begin*/
-
-  /* Handle '0' by itself end*/
-
   /* constants begin */
-  /* Do we need the checks for values at scanner level itself?*/
-{number}          {
-                   #if PARSER 
-                   yylval =  node_number(yytext);
-                   #endif
-                   return echoFcn(NUMBER);}
-{number}\.{number} {
-  printf("ERROR: floating point operation attempted at line %d\n",yylineno );
-                  return -1;}
+{number}    yylval = node_number(yytext); return NUMBER;
   /* constants end */
-  
-  /* reserved words begin*/
-do          return echoFcn(DO);
-for         return echoFcn(FOR);
-return      return echoFcn(RETURN);
-break       return echoFcn(BREAK);
-short       return echoFcn(SHORT);
-else        return echoFcn(ELSE);
-goto        return echoFcn(GOTO);
-signed      return echoFcn(SIGNED);
-unsigned    return echoFcn(UNSIGNED);
-char        return echoFcn(CHAR);
-if          return echoFcn(IF);
-void        return echoFcn(VOID);
-int         return echoFcn(INT);
-continue    return echoFcn(CONTINUE);
-long        return echoFcn(LONG);
-while       return echoFcn(WHILE);
-  /* reserved words end*/
 
   /* identifiers */
-{id}        {
-             #if PARSER
-             yylval = node_identifier(yytext, yyleng);
-             #endif
-             return echoFcn(IDENTIFIER); }
-
-  /* Handle escape sequences*/
-"\\n"           {return ('\n');}
-"\\t"           {return ('\t'); }                 
-"\\r"           {return ('\r'); }                 
-"\\b"           {return ('\b'); }                 
-"\\f"           {return ('\f'); }                 
-"\\v"           {return ('\v');}
-"\\a"           {return ('\a');}
-"\\\'"          {return ('\'');}
-"\\\""          {return ('\"');}
-"\\?"           {return ('\?');}
-
-\\[0-7]{1,3}  {
-		   unsigned int result;
-		   (void) sscanf( yytext + 1, "%o", &result );
-		   if ( result > 0xff )
-                     {
-		       printf("ERROR: Constant is out of bounds at line %d\n", yylineno);
-                     }
-		   *string_buf_ptr++ = result;
-		   }
-\\{number}      { printf("ERROR: Constant is out of bounds at line %d\n", yylineno);} 
+{id}        yylval = node_identifier(yytext, yyleng); return IDENTIFIER;
 
- /* Handle different integer sizes */
+.           return -1;
 
- /* Handle character begin*/
-\'\'                {printf("ERROR: empty char invalid at line %d\n", yylineno); return -1;}
-\'(\\\\)\'           {return nodeFromChar('\\');}
-\'(\\n)\'           {return nodeFromChar('\n');}
-\'(\\t)\'           {return nodeFromChar('\t');}                 
-\'(\\r)\'           {return nodeFromChar('\r'); }                 
-\'(\\b)\'           {return nodeFromChar('\b'); }                 
-\'(\\f)\'           {return nodeFromChar('\f'); }                 
-\'(\\v)\'           {return nodeFromChar('\v');}
-\'(\\a)\'           {return nodeFromChar('\a');}
-\'(\\\')\'          {return nodeFromChar('\'');}
-\'(\\\")\'          {return nodeFromChar('\"');}
-\'"\\?"\'           {return nodeFromChar('\?');}
-\'(\\[0-7]{1,3})\'  {unsigned int result;
-  (void) sscanf( yytext + 1, "%o", &result );
-  if ( result > 0xff )
-    {
-      printf("ERROR: Constant is out of bounds 1 at line %d\n", yylineno);
-    }
-  return nodeFromChar(result);
-		}
-\'(\\{number})\'      {printf("ERROR: Constant is out of bounds at line %d\n", yylineno);} 
-\'([^\']+)\'           {/*Rest of single characters*/
-  if (yyleng > 3)
-    {
-      printf("ERROR:Invalid multi character entry:%s at line %d\n", yytext, yylineno); return -1;
-    }
-    char * yptr = yytext;
-    return nodeFromChar(*(yptr+1)); }
-
-  /* Handle character end*/
-
-  /* Handle Strings begin */
-
-\"             {string_buf_ptr = string_buf;BEGIN(string);}
-
-<string>{
-   {newline}   {printf("ERROR:String broken by newline at %d\n", yylineno);return -1;}
-   <<EOF>>     {printf("ERROR:Untermintaed string ended by EOF\n");return -1;}
-   \"          { *string_buf_ptr++ = '\0'; 
-              #if DEBUG
-                 printf("STRING value:%s \n", string_buf);
-              #endif
-
-                 #if PARSER
-                 yylval = node_string(string_buf, (string_buf_ptr-string_buf)/sizeof(char));
-                 #endif
-	         BEGIN(INITIAL); return echoFcn(STRING);}
-   [^\\\n\"]+   {char * yptr = yytext; 
-                 while(*yptr)
-                   *string_buf_ptr++ = *yptr++;}
-   \\\n         /* Do nothing with continuation*/
-   \\n          {*string_buf_ptr++ = '\n';}
-   \\\\         {*string_buf_ptr++ = '\\';}
-   \\t          {*string_buf_ptr++ = '\t';}                 
-   \\r          {*string_buf_ptr++ = '\r';}                 
-   \\b          {*string_buf_ptr++ = '\b';}                 
-   \\f          {*string_buf_ptr++ = '\f';}                 
-   \\v          {*string_buf_ptr++ = '\v';}
-   \\a          {*string_buf_ptr++ = '\a';}
-   \\\'         {*string_buf_ptr++ = '\'';}
-   \\\"         {*string_buf_ptr++ = '\"';}
-   \\?          {*string_buf_ptr++ = '\?';}
-   \\[0-7]{1,3} {/* octal escape sequence */
-		   unsigned int result;
-		   (void) sscanf( yytext + 1, "%o", &result );
-		   if ( result > 0xff )
-		     printf("ERROR: Constant is out of bounds at %d\n", yylineno);
-		   *string_buf_ptr++ = result;}
-   \\{number}      {printf("ERROR:Bad escape sequence passed at %d\n", yylineno);}
-}
-  /* Handle Strings end */
-
-  /* Handle Comments begin */
-"*/"          {printf("Unmatched comment at %d \n",yylineno); return -1;}
-"/*"          {BEGIN(comment);}
-<comment>{
-      "*/"    {BEGIN(INITIAL);}
-      [^*]+   {/*Do nothing */}
-      "*"     /*Do nothing again*/
-	<<EOF>> {printf("Comment not terminated\n");BEGIN(INITIAL);return -1;}
-}
-  /* Handle Comments end */
-
-
-  /* Specific Error conditions begin */
-
-  /* 1. Carriage return alone - error*/
-
-  /* 2. Carriage return alone - error*/
-  /* Error conditions end*/
- <<EOF>>     {printf("Successful completion\n"); return 0;}
-.           {printf("ERROR: Unmatched rule at %d\n",yylineno);return -1;}
 %%
-int echoFcn(int tokenId)
-{
-#if DEBUG
-  static const char *const debugIDName[] =
-  { "IDENTIFIER", "NUMBER", "STRING",
-  "BREAK", "CHAR", "CONTINUE", "DO", "ELSE", "FOR", "GOTO", "IF", "INT",
-  "LONG", "RETURN", "SHORT", "SIGNED", "UNSIGNED", "VOID", "WHILE",
-  "LEFT_PAREN", "RIGHT_PAREN", "LEFT_SQUARE", "RIGHT_SQUARE", "LEFT_CURLY",
-  "RIGHT_CURLY", "AMPERSAND", "ASTERISK", "CARET", "COLON", "COMMA",
-  "EQUAL", "EXCLAMATION", "GREATER", "LESS", "MINUS", "PERCENT", "PLUS",
-  "SEMICOLON", "SLASH", "QUESTION", "TILDE", "VBAR", "AMPERSAND_AMPERSAND",
-  "AMPERSAND_EQUAL", "ASTERISK_EQUAL", "CARET_EQUAL", "EQUAL_EQUAL",
-  "EXCLAMATION_EQUAL", "GREATER_EQUAL", "GREATER_GREATER",
-  "GREATER_GREATER_EQUAL", "LESS_EQUAL", "LESS_LESS", "LESS_LESS_EQUAL",
-  "MINUS_EQUAL", "MINUS_MINUS", "PERCENT_EQUAL", "PLUS_EQUAL", "PLUS_PLUS",
-  "SLASH_EQUAL", "VBAR_EQUAL", "VBAR_VBAR"};
-
-  printf(" %s \n", debugIDName[tokenId - IDENTIFIER]);
-#endif
-
-  return tokenId;
-}
-
-int nodeFromChar(int charVal)
-{    
-#if PARSER
-    char str[15];
-    sprintf(str, "%d", charVal);
-    yylval = node_number(str);
-#endif   
-
-#if DEBUG
-    printf("Char: %c \n", charVal);
-#endif
-    return echoFcn(NUMBER);
-}
diff --git a/src/scanner.lex b/src/scanner.lex
deleted file mode 100644
index 253594c..0000000
--- a/src/scanner.lex
+++ /dev/null
@@ -1,313 +0,0 @@
-%option yylineno
-%option nounput
-
-%{
-/*
- * scanner.lex
- *
- * This file contains the specification for the (f)lex generated scanner
- * for the CSCI-E295 source language.
- *
- */
-
-  #include <stdlib.h>
-  #include <errno.h>
-  #include <string.h>
-
- #define PARSER_DEFINED 1 /* To avoid any parser specific code in standalone builds*/
- #define DEBUG 0 /*If you want debug messages printed - for standalone builds */
-
- #if PARSER_DEFINED
-  #define YYSTYPE struct node *
- #endif
-
-  #define YY_NO_INPUT
-
- #if PARSER_DEFINED
-  #include "node.h"
-  #include "parser.h"
- #else
-  #include "testToken.h"
- #endif 
-  #define MAX_STR_CONST 509 /*From C89 standards*/
-
-
-  void errorFcn(char const* message);
-  int echoFcn(int tokenId);
-  int nodeFromChar(int charVal);
-  extern void yyerror(char const* message);
-%}
-
-newline         \n[\r]?
-ws              [ \t\v\f]
-
-digit           [[:digit:]]
-letter          [[:alpha:]]
-
-graphicalChar   [\$\@\`\*\+\-\/]
-
-id              ({letter}|_)({letter}|{digit}|_)*
-number          {digit}+
-
-%x              comment
-%x              string
-%%
-     char string_buf[MAX_STR_CONST];
-     char *string_buf_ptr = NULL;
-{newline}   /* do nothing; lex is counting lines */
-{ws}        /* do nothing */
-
-  /* operators begin */
-\*          return echoFcn(ASTERISK);
-\+          return echoFcn(PLUS);
-\-           return echoFcn(MINUS);
-\/          return echoFcn(SLASH);
-\=          return echoFcn(EQUAL);
-\%           return echoFcn(PERCENT);
-\&           return echoFcn(AMPERSAND);
-\<           return echoFcn(LESS);
-\>           return echoFcn(GREATER);
-\?           return echoFcn(QUESTION);
-\|           return echoFcn(VBAR);
-
-\&&          return echoFcn(AMPERSAND_AMPERSAND);
-\&=          return echoFcn(AMPERSAND_EQUAL);
-\*=          return echoFcn(ASTERISK_EQUAL);
-\^=          return echoFcn(CARET_EQUAL);
-\==          return echoFcn(EQUAL_EQUAL);
-\!=          return echoFcn(EXCLAMATION_EQUAL);
-\>=          return echoFcn(GREATER_EQUAL);
-\>>          return echoFcn(GREATER_GREATER);
-\>>=         return echoFcn(GREATER_GREATER_EQUAL);
-\<=          return echoFcn(LESS_EQUAL);
-\<<          return echoFcn(LESS_LESS);
-\<<=         return echoFcn(LESS_LESS_EQUAL);
-\-=          return echoFcn(MINUS_EQUAL);
-\%=          return echoFcn(PERCENT_EQUAL);
-\+=          return echoFcn(PLUS_EQUAL);
-\/=          return echoFcn(SLASH_EQUAL);
-\|=          return echoFcn(VBAR_EQUAL);
-\|\|          return echoFcn(VBAR_VBAR);
-
-  /* operators end */
-
-  /* Separator*/
-\(          return echoFcn(LEFT_PAREN);
-\)          return echoFcn(RIGHT_PAREN);
-\{           return echoFcn(LEFT_CURLY);
-\}           return echoFcn(RIGHT_CURLY);
-\[           return echoFcn(LEFT_SQUARE);
-\]           return echoFcn(RIGHT_SQUARE);
-
-,           return echoFcn(COMMA);
-:           return echoFcn(COLON);
-!          return echoFcn(EXCLAMATION);
-;            return echoFcn(SEMICOLON);
-
-
-  /* Handle '0' by itself begin*/
-
-  /* Handle '0' by itself end*/
-
-  /* constants begin */
-  /* Do we need the checks for values at scanner level itself?*/
-{number}          {
-                   #if PARSER_DEFINED 
-                   yylval =  node_number(yytext);
-                   #endif
-                   return echoFcn(NUMBER);}
-{number}\.{number} {
-  errorFcn("floating point operation attempted");
-                  return -1;}
-  /* constants end */
-  
-  /* reserved words begin*/
-do          return echoFcn(DO);
-for         return echoFcn(FOR);
-return      return echoFcn(RETURN);
-break       return echoFcn(BREAK);
-short       return echoFcn(SHORT);
-else        return echoFcn(ELSE);
-goto        return echoFcn(GOTO);
-signed      return echoFcn(SIGNED);
-unsigned    return echoFcn(UNSIGNED);
-char        return echoFcn(CHAR);
-if          return echoFcn(IF);
-void        return echoFcn(VOID);
-int         return echoFcn(INT);
-continue    return echoFcn(CONTINUE);
-long        return echoFcn(LONG);
-while       return echoFcn(WHILE);
-  /* reserved words end*/
-
-  /* identifiers */
-{id}        {
-             #if PARSER_DEFINED
-             yylval = node_identifier(yytext, yyleng);
-             #endif
-             return echoFcn(IDENTIFIER); }
-
-  /* Handle escape sequences*/
-"\\n"           {return ('\n');}
-"\\t"           {return ('\t'); }                 
-"\\r"           {return ('\r'); }                 
-"\\b"           {return ('\b'); }                 
-"\\f"           {return ('\f'); }                 
-"\\v"           {return ('\v');}
-"\\a"           {return ('\a');}
-"\\\'"          {return ('\'');}
-"\\\""          {return ('\"');}
-"\\?"           {return ('\?');}
-
-\\[0-7]{1,3}  {
-		   unsigned int result;
-		   (void) sscanf( yytext + 1, "%o", &result );
-		   if ( result > 0xff )
-                     {
-                      errorFcn("Constant is out of bounds at line");
-                     }
-		   *string_buf_ptr++ = result;
-		   }
-\\{number}      { errorFcn("Constant is out of bounds");} 
-
- /* Handle different integer sizes */
-
- /* Handle character begin*/
-\'\'                {errorFcn("empty char invalid"); return -1;}
-\'(\\\\)\'           {return nodeFromChar('\\');}
-\'(\\n)\'           {return nodeFromChar('\n');}
-\'(\\t)\'           {return nodeFromChar('\t');}                 
-\'(\\r)\'           {return nodeFromChar('\r'); }                 
-\'(\\b)\'           {return nodeFromChar('\b'); }                 
-\'(\\f)\'           {return nodeFromChar('\f'); }                 
-\'(\\v)\'           {return nodeFromChar('\v');}
-\'(\\a)\'           {return nodeFromChar('\a');}
-\'(\\\')\'          {return nodeFromChar('\'');}
-\'(\\\")\'          {return nodeFromChar('\"');}
-\'"\\?"\'           {return nodeFromChar('\?');}
-\'(\\[0-7]{1,3})\'  {unsigned int result;
-  (void) sscanf( yytext + 1, "%o", &result );
-  if ( result > 0xff )
-    {
-      errorFcn("Constant is out of bounds 1");
-    }
-  return nodeFromChar(result);
-		}
-\'(\\{number})\'      {errorFcn("Constant is out of bounds");} 
-\'([^\']+)\'          {/*Rest of single characters*/
-                       char* yptr = yytext;
-                        if (yyleng > 3)
-                         {
-                            errorFcn("Invalid multi character entry"); return -1;
-                         }
-			return nodeFromChar(*(yptr+1)); }
-
-  /* Handle character end*/
-
-  /* Handle Strings begin */
-
-\"             {string_buf_ptr = string_buf;BEGIN(string);}
-
-<string>{
-  {newline}   {errorFcn("String broken by newline");return -1;}
-  <<EOF>>     {errorFcn("Untermintaed string ended by EOF");return -1;}
-   \"          { *string_buf_ptr++ = '\0'; 
-              #if DEBUG
-                 printf("STRING value:%s \n", string_buf);
-              #endif
-
-                 #if PARSER_DEFINED
-                 yylval = node_string(string_buf, (string_buf_ptr-string_buf)/sizeof(char));
-                 #endif
-	         BEGIN(INITIAL); return echoFcn(STRING);}
-   [^\\\n\"]+   {char * yptr = yytext; 
-                 while(*yptr)
-                   *string_buf_ptr++ = *yptr++;}
-   \\\n         /* Do nothing with continuation*/
-   \\n          {*string_buf_ptr++ = '\n';}
-   \\\\         {*string_buf_ptr++ = '\\';}
-   \\t          {*string_buf_ptr++ = '\t';}                 
-   \\r          {*string_buf_ptr++ = '\r';}                 
-   \\b          {*string_buf_ptr++ = '\b';}                 
-   \\f          {*string_buf_ptr++ = '\f';}                 
-   \\v          {*string_buf_ptr++ = '\v';}
-   \\a          {*string_buf_ptr++ = '\a';}
-   \\\'         {*string_buf_ptr++ = '\'';}
-   \\\"         {*string_buf_ptr++ = '\"';}
-   \\?          {*string_buf_ptr++ = '\?';}
-   \\[0-7]{1,3} {/* octal escape sequence */
-		   unsigned int result;
-		   (void) sscanf( yytext + 1, "%o", &result );
-		   if ( result > 0xff )
-		     errorFcn("Constant is out of bounds");
-		   *string_buf_ptr++ = result;}
-   \\{number}      {errorFcn("Bad escape sequence passed");}
-}
-  /* Handle Strings end */
-
-  /* Handle Comments begin */
-"*/"          {errorFcn("Unmatched comment"); return -1;}
-"/*"          {BEGIN(comment);}
-<comment>{
-      "*/"    {BEGIN(INITIAL);}
-      [^*]+   {/*Do nothing */}
-      "*"     /*Do nothing again*/
-	<<EOF>> {errorFcn("Comment not terminated");BEGIN(INITIAL);return -1;}
-}
-  /* Handle Comments end */
-
-
-  /* Specific Error conditions begin */
-
-  /* 1. Carriage return alone - error*/
-
-  /* 2. Carriage return alone - error*/
-  /* Error conditions end*/
- <<EOF>>     {printf("Successful completion\n"); return 0;}
-.           {errorFcn(" Unmatched rule");return -1;}
-%%
-int echoFcn(int tokenId)
-{
-#if DEBUG
-  static const char *const debugIDName[] =
-  { "IDENTIFIER", "NUMBER", "STRING",
-  "BREAK", "CHAR", "CONTINUE", "DO", "ELSE", "FOR", "GOTO", "IF", "INT",
-  "LONG", "RETURN", "SHORT", "SIGNED", "UNSIGNED", "VOID", "WHILE",
-  "LEFT_PAREN", "RIGHT_PAREN", "LEFT_SQUARE", "RIGHT_SQUARE", "LEFT_CURLY",
-  "RIGHT_CURLY", "AMPERSAND", "ASTERISK", "CARET", "COLON", "COMMA",
-  "EQUAL", "EXCLAMATION", "GREATER", "LESS", "MINUS", "PERCENT", "PLUS",
-  "SEMICOLON", "SLASH", "QUESTION", "TILDE", "VBAR", "AMPERSAND_AMPERSAND",
-  "AMPERSAND_EQUAL", "ASTERISK_EQUAL", "CARET_EQUAL", "EQUAL_EQUAL",
-  "EXCLAMATION_EQUAL", "GREATER_EQUAL", "GREATER_GREATER",
-  "GREATER_GREATER_EQUAL", "LESS_EQUAL", "LESS_LESS", "LESS_LESS_EQUAL",
-  "MINUS_EQUAL", "MINUS_MINUS", "PERCENT_EQUAL", "PLUS_EQUAL", "PLUS_PLUS",
-  "SLASH_EQUAL", "VBAR_EQUAL", "VBAR_VBAR"};
-
-  printf(" %s \n", debugIDName[tokenId - IDENTIFIER]);
-#endif
-
-  return tokenId;
-}
-
-int nodeFromChar(int charVal)
-{    
-#if PARSER_DEFINED
-    char str[15];
-    sprintf(str, "%d", charVal);
-    yylval = node_number(str);
-#endif   
-
-#if DEBUG
-    printf("Char: %c \n", charVal);
-#endif
-    return echoFcn(NUMBER);
-}
-
-void errorFcn(char const* message)
-{
-#if PARSER_DEFINED
-     yyerror(message);
-#else
-     printf("\n ERROR: %s at %d for %s\n", message,yylineno, yytext);
-#endif
-}
diff --git a/src/standaloneMakefile b/src/standaloneMakefile
deleted file mode 100644
index 029f31a..0000000
--- a/src/standaloneMakefile
+++ /dev/null
@@ -1,31 +0,0 @@
-CC = gcc
-CFLAGS += -g -Wall -Wextra -pedantic
-
-CXX = g++
-CXXFLAGS +=
-
-LEX = flex
-LEXFLAGS += --header-file=scanner.h
-
-# Flags passed to the preprocessor.
-CPPFLAGS += -I$(GTEST_DIR)/include
-
-# Flags passed to the C++ compiler.
-CXXFLAGS += -g -Wall -Wextra
-
-LDLIBS += -ll -ly
-LDFLAGS =
-
-EXECS = scanner
-# For standalone scanner make sure you set the PARSER to 0 and DEBUG to 1 in scanner.lex
-all: $(EXECS)
-
-clean :
-	rm -f $(EXECS) *.o lex.yy.c
-
-%.c : %.lex
-	$(LEX) $(LEXFLAGS) -o $@ $<
-scanner.o : scanner.c
-scanner: scanner.o
-	$(CC) -o $@ $(LDFLAGS) $^ $(LDLIBS)
-
diff --git a/src/testToken.h b/src/testToken.h
deleted file mode 100644
index 1b62c4c..0000000
--- a/src/testToken.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* Token type.  */
-#ifndef YY_NULLPTR
-#define YY_NULLPTR 0
-#endif
-
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    IDENTIFIER = 258,
-    NUMBER = 259,
-    STRING = 260,
-    BREAK = 261,
-    CHAR = 262,
-    CONTINUE = 263,
-    DO = 264,
-    ELSE = 265,
-    FOR = 266,
-    GOTO = 267,
-    IF = 268,
-    INT = 269,
-    LONG = 270,
-    RETURN = 271,
-    SHORT = 272,
-    SIGNED = 273,
-    UNSIGNED = 274,
-    VOID = 275,
-    WHILE = 276,
-    LEFT_PAREN = 277,
-    RIGHT_PAREN = 278,
-    LEFT_SQUARE = 279,
-    RIGHT_SQUARE = 280,
-    LEFT_CURLY = 281,
-    RIGHT_CURLY = 282,
-    AMPERSAND = 283,
-    ASTERISK = 284,
-    CARET = 285,
-    COLON = 286,
-    COMMA = 287,
-    EQUAL = 288,
-    EXCLAMATION = 289,
-    GREATER = 290,
-    LESS = 291,
-    MINUS = 292,
-    PERCENT = 293,
-    PLUS = 294,
-    SEMICOLON = 295,
-    SLASH = 296,
-    QUESTION = 297,
-    TILDE = 298,
-    VBAR = 299,
-    AMPERSAND_AMPERSAND = 300,
-    AMPERSAND_EQUAL = 301,
-    ASTERISK_EQUAL = 302,
-    CARET_EQUAL = 303,
-    EQUAL_EQUAL = 304,
-    EXCLAMATION_EQUAL = 305,
-    GREATER_EQUAL = 306,
-    GREATER_GREATER = 307,
-    GREATER_GREATER_EQUAL = 308,
-    LESS_EQUAL = 309,
-    LESS_LESS = 310,
-    LESS_LESS_EQUAL = 311,
-    MINUS_EQUAL = 312,
-    MINUS_MINUS = 313,
-    PERCENT_EQUAL = 314,
-    PLUS_EQUAL = 315,
-    PLUS_PLUS = 316,
-    SLASH_EQUAL = 317,
-    VBAR_EQUAL = 318,
-    VBAR_VBAR = 319
-  };
-
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "IDENTIFIER", "NUMBER", "STRING",
-  "BREAK", "CHAR", "CONTINUE", "DO", "ELSE", "FOR", "GOTO", "IF", "INT",
-  "LONG", "RETURN", "SHORT", "SIGNED", "UNSIGNED", "VOID", "WHILE",
-  "LEFT_PAREN", "RIGHT_PAREN", "LEFT_SQUARE", "RIGHT_SQUARE", "LEFT_CURLY",
-  "RIGHT_CURLY", "AMPERSAND", "ASTERISK", "CARET", "COLON", "COMMA",
-  "EQUAL", "EXCLAMATION", "GREATER", "LESS", "MINUS", "PERCENT", "PLUS",
-  "SEMICOLON", "SLASH", "QUESTION", "TILDE", "VBAR", "AMPERSAND_AMPERSAND",
-  "AMPERSAND_EQUAL", "ASTERISK_EQUAL", "CARET_EQUAL", "EQUAL_EQUAL",
-  "EXCLAMATION_EQUAL", "GREATER_EQUAL", "GREATER_GREATER",
-  "GREATER_GREATER_EQUAL", "LESS_EQUAL", "LESS_LESS", "LESS_LESS_EQUAL",
-  "MINUS_EQUAL", "MINUS_MINUS", "PERCENT_EQUAL", "PLUS_EQUAL", "PLUS_PLUS",
-  "SLASH_EQUAL", "VBAR_EQUAL", "VBAR_VBAR", "$accept", "additive_expr",
-  "assignment_expr", "expr", "identifier", "multiplicative_expr",
-  "primary_expr", "program", "statement", "statement_list", YY_NULLPTR
-};
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef int YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
diff --git a/src/tokens.txt b/src/tokens.txt
deleted file mode 100644
index a084a31..0000000
--- a/src/tokens.txt
+++ /dev/null
@@ -1,68 +0,0 @@
-0 1 2 3 4 5 6 7 8 9
-35 99 100 101 384 2847 25325 32767
-32768 65535 65536 120394857 2147483647
-2147483648 3249093841 4294967295
-4294967296 12345678901234567890
-
-000
-
-39th
-
-a b c d e f g h i j k l m n o p q r s t u v w x y z
-A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
-user _user user19 user_28_username
-User _USER UsEr19 useR_20_UserName
-
-break char continue do else for goto if int long return short signed unsigned void while
-breakx charx continuex dox elsex forx gotox ifx intx longx returnx shortx signedx unsignedx voidx whilex
-xbreak xchar xcontinue xdo xelse xfor xgoto xif xint xlong xreturn xshort xsigned xunsigned xvoid xwhile
-break5 char5 continue5 do5 else5 for5 goto5 if5 int5 long5 return5 short5 signed5 unsigned5 void5 while5
-5break 5char 5continue 5do 5else 5for 5goto 5if 5int 5long 5return 5short 5signed 5unsigned 5void 5while
-
-/**/
-/* */
-
-/* hi there
- * test
- */
-
-a/* hi 
- there */bc
-
-! % ^ & * - + = ~ | < > / ?
-+= -= *= /= <<= >>= &= ^= |=
-++ -- << >> <= >= == != && ||
-
-( ) [ ] { } , ; :
-
-"a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z" 
-"A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
-
-"$" "@" "`"
-
-"" "a" "ab" "abc" "abcdefghijklmnopqrstuvwxyz"
-
-"\n" "\t" "\b" "\r" "\f" "\v" "\\" "\'" "\"" "\a" "\?" "\0" "\41" "\101"
-"bla\gh" "string"
-"\415" "string"
-"\41g" "string"
-"this string should not\0terminate"
-
-'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' 
-'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
-
-'$' '@' '`'
-
-''
-'ab'
-
-'\n' '\t' '\b' '\r' '\f' '\v' '\\' '\'' '\"' '\a' '\?' '\0' '\41' '\101'
-'\0' '\72' '\137' '\377' 
-'\777' 
-'\g'
-
-/ * */
-/* * /
-/* */ */
-/* /* */ */
-/*
\ No newline at end of file
